//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.7 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.02.03 at 05:40:36 PM CST 
//


package au.org.ecoinformatics.eml.jaxb.eml;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;


/**
 * <p>Java class for ProtocolType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="ProtocolType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;choice>
 *         &lt;sequence>
 *           &lt;group ref="{eml://ecoinformatics.org/resource-2.1.1}ResourceGroup"/>
 *           &lt;element name="proceduralStep" type="{eml://ecoinformatics.org/methods-2.1.1}ProcedureStepType" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;/sequence>
 *         &lt;group ref="{eml://ecoinformatics.org/resource-2.1.1}ReferencesGroup"/>
 *       &lt;/choice>
 *       &lt;attribute name="id" type="{eml://ecoinformatics.org/resource-2.1.1}IDType" />
 *       &lt;attribute name="system" type="{eml://ecoinformatics.org/resource-2.1.1}SystemType" />
 *       &lt;attribute name="scope" type="{eml://ecoinformatics.org/resource-2.1.1}ScopeType" default="document" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ProtocolType", namespace = "eml://ecoinformatics.org/protocol-2.1.1", propOrder = {
    "alternateIdentifier",
    "shortName",
    "title",
    "creator",
    "metadataProvider",
    "associatedParty",
    "pubDate",
    "language",
    "series",
    "_abstract",
    "keywordSet",
    "additionalInfo",
    "intellectualRights",
    "distribution",
    "coverage",
    "proceduralStep",
    "references"
})
public class ProtocolType {

    protected List<ProtocolType.AlternateIdentifier> alternateIdentifier;
    protected String shortName;
    protected List<I18NNonEmptyStringType> title;
    protected List<ResponsibleParty> creator;
    protected List<ResponsibleParty> metadataProvider;
    protected List<ProtocolType.AssociatedParty> associatedParty;
    protected String pubDate;
    protected I18NNonEmptyStringType language;
    protected String series;
    @XmlElement(name = "abstract")
    protected TextType _abstract;
    protected List<ProtocolType.KeywordSet> keywordSet;
    protected List<TextType> additionalInfo;
    protected TextType intellectualRights;
    protected List<DistributionType> distribution;
    protected Coverage coverage;
    protected List<ProcedureStepType> proceduralStep;
    protected au.org.ecoinformatics.eml.jaxb.eml.ViewType.References references;
    @XmlAttribute(name = "id")
    protected List<String> id;
    @XmlAttribute(name = "system")
    protected List<String> system;
    @XmlAttribute(name = "scope")
    protected ScopeType scope;

    /**
     * Gets the value of the alternateIdentifier property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the alternateIdentifier property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAlternateIdentifier().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProtocolType.AlternateIdentifier }
     * 
     * 
     */
    public List<ProtocolType.AlternateIdentifier> getAlternateIdentifier() {
        if (alternateIdentifier == null) {
            alternateIdentifier = new ArrayList<ProtocolType.AlternateIdentifier>();
        }
        return this.alternateIdentifier;
    }

    /**
     * Gets the value of the shortName property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getShortName() {
        return shortName;
    }

    /**
     * Sets the value of the shortName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setShortName(String value) {
        this.shortName = value;
    }

    /**
     * Gets the value of the title property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the title property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTitle().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link I18NNonEmptyStringType }
     * 
     * 
     */
    public List<I18NNonEmptyStringType> getTitle() {
        if (title == null) {
            title = new ArrayList<I18NNonEmptyStringType>();
        }
        return this.title;
    }

    /**
     * Gets the value of the creator property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the creator property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCreator().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ResponsibleParty }
     * 
     * 
     */
    public List<ResponsibleParty> getCreator() {
        if (creator == null) {
            creator = new ArrayList<ResponsibleParty>();
        }
        return this.creator;
    }

    /**
     * Gets the value of the metadataProvider property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the metadataProvider property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getMetadataProvider().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ResponsibleParty }
     * 
     * 
     */
    public List<ResponsibleParty> getMetadataProvider() {
        if (metadataProvider == null) {
            metadataProvider = new ArrayList<ResponsibleParty>();
        }
        return this.metadataProvider;
    }

    /**
     * Gets the value of the associatedParty property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the associatedParty property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAssociatedParty().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProtocolType.AssociatedParty }
     * 
     * 
     */
    public List<ProtocolType.AssociatedParty> getAssociatedParty() {
        if (associatedParty == null) {
            associatedParty = new ArrayList<ProtocolType.AssociatedParty>();
        }
        return this.associatedParty;
    }

    /**
     * Gets the value of the pubDate property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getPubDate() {
        return pubDate;
    }

    /**
     * Sets the value of the pubDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setPubDate(String value) {
        this.pubDate = value;
    }

    /**
     * Gets the value of the language property.
     * 
     * @return
     *     possible object is
     *     {@link I18NNonEmptyStringType }
     *     
     */
    public I18NNonEmptyStringType getLanguage() {
        return language;
    }

    /**
     * Sets the value of the language property.
     * 
     * @param value
     *     allowed object is
     *     {@link I18NNonEmptyStringType }
     *     
     */
    public void setLanguage(I18NNonEmptyStringType value) {
        this.language = value;
    }

    /**
     * Gets the value of the series property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getSeries() {
        return series;
    }

    /**
     * Sets the value of the series property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSeries(String value) {
        this.series = value;
    }

    /**
     * Gets the value of the abstract property.
     * 
     * @return
     *     possible object is
     *     {@link TextType }
     *     
     */
    public TextType getAbstract() {
        return _abstract;
    }

    /**
     * Sets the value of the abstract property.
     * 
     * @param value
     *     allowed object is
     *     {@link TextType }
     *     
     */
    public void setAbstract(TextType value) {
        this._abstract = value;
    }

    /**
     * Gets the value of the keywordSet property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the keywordSet property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getKeywordSet().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProtocolType.KeywordSet }
     * 
     * 
     */
    public List<ProtocolType.KeywordSet> getKeywordSet() {
        if (keywordSet == null) {
            keywordSet = new ArrayList<ProtocolType.KeywordSet>();
        }
        return this.keywordSet;
    }

    /**
     * Gets the value of the additionalInfo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the additionalInfo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAdditionalInfo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TextType }
     * 
     * 
     */
    public List<TextType> getAdditionalInfo() {
        if (additionalInfo == null) {
            additionalInfo = new ArrayList<TextType>();
        }
        return this.additionalInfo;
    }

    /**
     * Gets the value of the intellectualRights property.
     * 
     * @return
     *     possible object is
     *     {@link TextType }
     *     
     */
    public TextType getIntellectualRights() {
        return intellectualRights;
    }

    /**
     * Sets the value of the intellectualRights property.
     * 
     * @param value
     *     allowed object is
     *     {@link TextType }
     *     
     */
    public void setIntellectualRights(TextType value) {
        this.intellectualRights = value;
    }

    /**
     * Gets the value of the distribution property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the distribution property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDistribution().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DistributionType }
     * 
     * 
     */
    public List<DistributionType> getDistribution() {
        if (distribution == null) {
            distribution = new ArrayList<DistributionType>();
        }
        return this.distribution;
    }

    /**
     * Gets the value of the coverage property.
     * 
     * @return
     *     possible object is
     *     {@link Coverage }
     *     
     */
    public Coverage getCoverage() {
        return coverage;
    }

    /**
     * Sets the value of the coverage property.
     * 
     * @param value
     *     allowed object is
     *     {@link Coverage }
     *     
     */
    public void setCoverage(Coverage value) {
        this.coverage = value;
    }

    /**
     * Gets the value of the proceduralStep property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the proceduralStep property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getProceduralStep().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ProcedureStepType }
     * 
     * 
     */
    public List<ProcedureStepType> getProceduralStep() {
        if (proceduralStep == null) {
            proceduralStep = new ArrayList<ProcedureStepType>();
        }
        return this.proceduralStep;
    }

    /**
     * Gets the value of the references property.
     * 
     * @return
     *     possible object is
     *     {@link au.org.ecoinformatics.eml.jaxb.eml.ViewType.References }
     *     
     */
    public au.org.ecoinformatics.eml.jaxb.eml.ViewType.References getReferences() {
        return references;
    }

    /**
     * Sets the value of the references property.
     * 
     * @param value
     *     allowed object is
     *     {@link au.org.ecoinformatics.eml.jaxb.eml.ViewType.References }
     *     
     */
    public void setReferences(au.org.ecoinformatics.eml.jaxb.eml.ViewType.References value) {
        this.references = value;
    }

    /**
     * Gets the value of the id property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the id property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getId().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getId() {
        if (id == null) {
            id = new ArrayList<String>();
        }
        return this.id;
    }

    /**
     * Gets the value of the system property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the system property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSystem().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * 
     * 
     */
    public List<String> getSystem() {
        if (system == null) {
            system = new ArrayList<String>();
        }
        return this.system;
    }

    /**
     * Gets the value of the scope property.
     * 
     * @return
     *     possible object is
     *     {@link ScopeType }
     *     
     */
    public ScopeType getScope() {
        if (scope == null) {
            return ScopeType.DOCUMENT;
        } else {
            return scope;
        }
    }

    /**
     * Sets the value of the scope property.
     * 
     * @param value
     *     allowed object is
     *     {@link ScopeType }
     *     
     */
    public void setScope(ScopeType value) {
        this.scope = value;
    }

    public ProtocolType withAlternateIdentifier(ProtocolType.AlternateIdentifier... values) {
        if (values!= null) {
            for (ProtocolType.AlternateIdentifier value: values) {
                getAlternateIdentifier().add(value);
            }
        }
        return this;
    }

    public ProtocolType withAlternateIdentifier(Collection<ProtocolType.AlternateIdentifier> values) {
        if (values!= null) {
            getAlternateIdentifier().addAll(values);
        }
        return this;
    }

    public ProtocolType withShortName(String value) {
        setShortName(value);
        return this;
    }

    public ProtocolType withTitle(I18NNonEmptyStringType... values) {
        if (values!= null) {
            for (I18NNonEmptyStringType value: values) {
                getTitle().add(value);
            }
        }
        return this;
    }

    public ProtocolType withTitle(Collection<I18NNonEmptyStringType> values) {
        if (values!= null) {
            getTitle().addAll(values);
        }
        return this;
    }

    public ProtocolType withCreator(ResponsibleParty... values) {
        if (values!= null) {
            for (ResponsibleParty value: values) {
                getCreator().add(value);
            }
        }
        return this;
    }

    public ProtocolType withCreator(Collection<ResponsibleParty> values) {
        if (values!= null) {
            getCreator().addAll(values);
        }
        return this;
    }

    public ProtocolType withMetadataProvider(ResponsibleParty... values) {
        if (values!= null) {
            for (ResponsibleParty value: values) {
                getMetadataProvider().add(value);
            }
        }
        return this;
    }

    public ProtocolType withMetadataProvider(Collection<ResponsibleParty> values) {
        if (values!= null) {
            getMetadataProvider().addAll(values);
        }
        return this;
    }

    public ProtocolType withAssociatedParty(ProtocolType.AssociatedParty... values) {
        if (values!= null) {
            for (ProtocolType.AssociatedParty value: values) {
                getAssociatedParty().add(value);
            }
        }
        return this;
    }

    public ProtocolType withAssociatedParty(Collection<ProtocolType.AssociatedParty> values) {
        if (values!= null) {
            getAssociatedParty().addAll(values);
        }
        return this;
    }

    public ProtocolType withPubDate(String value) {
        setPubDate(value);
        return this;
    }

    public ProtocolType withLanguage(I18NNonEmptyStringType value) {
        setLanguage(value);
        return this;
    }

    public ProtocolType withSeries(String value) {
        setSeries(value);
        return this;
    }

    public ProtocolType withAbstract(TextType value) {
        setAbstract(value);
        return this;
    }

    public ProtocolType withKeywordSet(ProtocolType.KeywordSet... values) {
        if (values!= null) {
            for (ProtocolType.KeywordSet value: values) {
                getKeywordSet().add(value);
            }
        }
        return this;
    }

    public ProtocolType withKeywordSet(Collection<ProtocolType.KeywordSet> values) {
        if (values!= null) {
            getKeywordSet().addAll(values);
        }
        return this;
    }

    public ProtocolType withAdditionalInfo(TextType... values) {
        if (values!= null) {
            for (TextType value: values) {
                getAdditionalInfo().add(value);
            }
        }
        return this;
    }

    public ProtocolType withAdditionalInfo(Collection<TextType> values) {
        if (values!= null) {
            getAdditionalInfo().addAll(values);
        }
        return this;
    }

    public ProtocolType withIntellectualRights(TextType value) {
        setIntellectualRights(value);
        return this;
    }

    public ProtocolType withDistribution(DistributionType... values) {
        if (values!= null) {
            for (DistributionType value: values) {
                getDistribution().add(value);
            }
        }
        return this;
    }

    public ProtocolType withDistribution(Collection<DistributionType> values) {
        if (values!= null) {
            getDistribution().addAll(values);
        }
        return this;
    }

    public ProtocolType withCoverage(Coverage value) {
        setCoverage(value);
        return this;
    }

    public ProtocolType withProceduralStep(ProcedureStepType... values) {
        if (values!= null) {
            for (ProcedureStepType value: values) {
                getProceduralStep().add(value);
            }
        }
        return this;
    }

    public ProtocolType withProceduralStep(Collection<ProcedureStepType> values) {
        if (values!= null) {
            getProceduralStep().addAll(values);
        }
        return this;
    }

    public ProtocolType withReferences(au.org.ecoinformatics.eml.jaxb.eml.ViewType.References value) {
        setReferences(value);
        return this;
    }

    public ProtocolType withId(String... values) {
        if (values!= null) {
            for (String value: values) {
                getId().add(value);
            }
        }
        return this;
    }

    public ProtocolType withId(Collection<String> values) {
        if (values!= null) {
            getId().addAll(values);
        }
        return this;
    }

    public ProtocolType withSystem(String... values) {
        if (values!= null) {
            for (String value: values) {
                getSystem().add(value);
            }
        }
        return this;
    }

    public ProtocolType withSystem(Collection<String> values) {
        if (values!= null) {
            getSystem().addAll(values);
        }
        return this;
    }

    public ProtocolType withScope(ScopeType value) {
        setScope(value);
        return this;
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;simpleContent>
     *     &lt;extension base="&lt;http://www.w3.org/2001/XMLSchema>string">
     *       &lt;attribute name="system" type="{eml://ecoinformatics.org/resource-2.1.1}SystemType" />
     *     &lt;/extension>
     *   &lt;/simpleContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class AlternateIdentifier {

        @XmlValue
        protected String value;
        @XmlAttribute(name = "system")
        protected List<String> system;

        /**
         * Gets the value of the value property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setValue(String value) {
            this.value = value;
        }

        /**
         * Gets the value of the system property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the system property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getSystem().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         */
        public List<String> getSystem() {
            if (system == null) {
                system = new ArrayList<String>();
            }
            return this.system;
        }

        public ProtocolType.AlternateIdentifier withValue(String value) {
            setValue(value);
            return this;
        }

        public ProtocolType.AlternateIdentifier withSystem(String... values) {
            if (values!= null) {
                for (String value: values) {
                    getSystem().add(value);
                }
            }
            return this;
        }

        public ProtocolType.AlternateIdentifier withSystem(Collection<String> values) {
            if (values!= null) {
                getSystem().addAll(values);
            }
            return this;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;extension base="{eml://ecoinformatics.org/party-2.1.1}ResponsibleParty">
     *       &lt;sequence>
     *         &lt;element name="role" type="{eml://ecoinformatics.org/party-2.1.1}RoleType"/>
     *       &lt;/sequence>
     *     &lt;/extension>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "role"
    })
    public static class AssociatedParty
        extends ResponsibleParty
    {

        @XmlElement(required = true)
        protected String role;

        /**
         * Gets the value of the role property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getRole() {
            return role;
        }

        /**
         * Sets the value of the role property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setRole(String value) {
            this.role = value;
        }

        public ProtocolType.AssociatedParty withRole(String value) {
            setRole(value);
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withIndividualNameOrOrganizationNameOrPositionName(JAXBElement<?> ... values) {
            if (values!= null) {
                for (JAXBElement<?> value: values) {
                    getIndividualNameOrOrganizationNameOrPositionName().add(value);
                }
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withIndividualNameOrOrganizationNameOrPositionName(Collection<JAXBElement<?>> values) {
            if (values!= null) {
                getIndividualNameOrOrganizationNameOrPositionName().addAll(values);
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withAddress(Address... values) {
            if (values!= null) {
                for (Address value: values) {
                    getAddress().add(value);
                }
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withAddress(Collection<Address> values) {
            if (values!= null) {
                getAddress().addAll(values);
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withPhone(ResponsibleParty.Phone... values) {
            if (values!= null) {
                for (ResponsibleParty.Phone value: values) {
                    getPhone().add(value);
                }
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withPhone(Collection<ResponsibleParty.Phone> values) {
            if (values!= null) {
                getPhone().addAll(values);
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withElectronicMailAddress(I18NNonEmptyStringType... values) {
            if (values!= null) {
                for (I18NNonEmptyStringType value: values) {
                    getElectronicMailAddress().add(value);
                }
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withElectronicMailAddress(Collection<I18NNonEmptyStringType> values) {
            if (values!= null) {
                getElectronicMailAddress().addAll(values);
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withOnlineUrl(String... values) {
            if (values!= null) {
                for (String value: values) {
                    getOnlineUrl().add(value);
                }
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withOnlineUrl(Collection<String> values) {
            if (values!= null) {
                getOnlineUrl().addAll(values);
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withUserId(ResponsibleParty.UserId... values) {
            if (values!= null) {
                for (ResponsibleParty.UserId value: values) {
                    getUserId().add(value);
                }
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withUserId(Collection<ResponsibleParty.UserId> values) {
            if (values!= null) {
                getUserId().addAll(values);
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withReferences(au.org.ecoinformatics.eml.jaxb.eml.ViewType.References value) {
            setReferences(value);
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withId(String... values) {
            if (values!= null) {
                for (String value: values) {
                    getId().add(value);
                }
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withId(Collection<String> values) {
            if (values!= null) {
                getId().addAll(values);
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withSystem(String... values) {
            if (values!= null) {
                for (String value: values) {
                    getSystem().add(value);
                }
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withSystem(Collection<String> values) {
            if (values!= null) {
                getSystem().addAll(values);
            }
            return this;
        }

        @Override
        public ProtocolType.AssociatedParty withScope(ScopeType value) {
            setScope(value);
            return this;
        }

        /*
         * Added after JAXB generation by automatic application of a patch file
         */
        public ProtocolType.AssociatedParty withIndividualName(Person ... values) {
            super.withIndividualName(values);
            return this;
        }
        
        /*
         * Added after JAXB generation by automatic application of a patch file
         */
        public ProtocolType.AssociatedParty withOrganizationName(I18NNonEmptyStringType ... values) {
        	super.withOrganizationName(values);
        	return this;
        }
        
        /*
         * Added after JAXB generation by automatic application of a patch file
         */
        public ProtocolType.AssociatedParty withPositionName(I18NNonEmptyStringType ... values) {
            super.withPositionName(values);
            return this;
        }
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence>
     *         &lt;element name="keyword" maxOccurs="unbounded">
     *           &lt;complexType>
     *             &lt;complexContent>
     *               &lt;extension base="{eml://ecoinformatics.org/resource-2.1.1}i18nNonEmptyStringType">
     *                 &lt;attribute name="keywordType" type="{eml://ecoinformatics.org/resource-2.1.1}KeyTypeCode" />
     *               &lt;/extension>
     *             &lt;/complexContent>
     *           &lt;/complexType>
     *         &lt;/element>
     *         &lt;element name="keywordThesaurus" type="{eml://ecoinformatics.org/resource-2.1.1}NonEmptyStringType" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "keyword",
        "keywordThesaurus"
    })
    public static class KeywordSet {

        @XmlElement(required = true)
        protected List<ProtocolType.KeywordSet.Keyword> keyword;
        protected String keywordThesaurus;

        /**
         * Gets the value of the keyword property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the keyword property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getKeyword().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link ProtocolType.KeywordSet.Keyword }
         * 
         * 
         */
        public List<ProtocolType.KeywordSet.Keyword> getKeyword() {
            if (keyword == null) {
                keyword = new ArrayList<ProtocolType.KeywordSet.Keyword>();
            }
            return this.keyword;
        }

        /**
         * Gets the value of the keywordThesaurus property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getKeywordThesaurus() {
            return keywordThesaurus;
        }

        /**
         * Sets the value of the keywordThesaurus property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setKeywordThesaurus(String value) {
            this.keywordThesaurus = value;
        }

        public ProtocolType.KeywordSet withKeyword(ProtocolType.KeywordSet.Keyword... values) {
            if (values!= null) {
                for (ProtocolType.KeywordSet.Keyword value: values) {
                    getKeyword().add(value);
                }
            }
            return this;
        }

        public ProtocolType.KeywordSet withKeyword(Collection<ProtocolType.KeywordSet.Keyword> values) {
            if (values!= null) {
                getKeyword().addAll(values);
            }
            return this;
        }

        public ProtocolType.KeywordSet withKeywordThesaurus(String value) {
            setKeywordThesaurus(value);
            return this;
        }


        /**
         * <p>Java class for anonymous complex type.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.
         * 
         * <pre>
         * &lt;complexType>
         *   &lt;complexContent>
         *     &lt;extension base="{eml://ecoinformatics.org/resource-2.1.1}i18nNonEmptyStringType">
         *       &lt;attribute name="keywordType" type="{eml://ecoinformatics.org/resource-2.1.1}KeyTypeCode" />
         *     &lt;/extension>
         *   &lt;/complexContent>
         * &lt;/complexType>
         * </pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "")
        public static class Keyword
            extends I18NNonEmptyStringType
        {

            @XmlAttribute(name = "keywordType")
            protected KeyTypeCode keywordType;

            /**
             * Gets the value of the keywordType property.
             * 
             * @return
             *     possible object is
             *     {@link KeyTypeCode }
             *     
             */
            public KeyTypeCode getKeywordType() {
                return keywordType;
            }

            /**
             * Sets the value of the keywordType property.
             * 
             * @param value
             *     allowed object is
             *     {@link KeyTypeCode }
             *     
             */
            public void setKeywordType(KeyTypeCode value) {
                this.keywordType = value;
            }

            public ProtocolType.KeywordSet.Keyword withKeywordType(KeyTypeCode value) {
                setKeywordType(value);
                return this;
            }

            @Override
            public ProtocolType.KeywordSet.Keyword withContent(Serializable... values) {
                if (values!= null) {
                    for (Serializable value: values) {
                        getContent().add(value);
                    }
                }
                return this;
            }

            @Override
            public ProtocolType.KeywordSet.Keyword withContent(Collection<Serializable> values) {
                if (values!= null) {
                    getContent().addAll(values);
                }
                return this;
            }

            @Override
            public ProtocolType.KeywordSet.Keyword withLang(String value) {
                setLang(value);
                return this;
            }

        }

    }

}
